package list

/*
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

方法一：将值复制到数组中后用双指针法
思路
如果你还不太熟悉链表，下面有关于列表的概要讲述。
有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢？
数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由基于内存寻址的方式。
链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。
确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)O 的时间，因为访问每个元素的时间是 O(1)O(1)，而有 nn 个元素要访问。

然而同样的方法在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。

*/
func isPalindrome(head *ListNode) bool {
	if head == nil {
		return false
	}

	val := make([]int, 0)
	for ; head != nil; head=head.Next{
		val = append(val, head.Val)
	}

	l := len(val)
	for i,v := range val[:l/2] {
		if v != val[l-1-i] {
			return false
		}
	}
	return true
}
